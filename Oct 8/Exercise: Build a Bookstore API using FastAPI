from fastapi import FastAPI, HTTPException, Query
from pydantic import BaseModel, Field
from typing import Optional, List

app = FastAPI()

# Pydantic Model
class Book(BaseModel):
    id: int
    title: str
    author: str
    price: float
    in_stock: bool


# In-memory list of books
books = [
    {"id": 1, "title": "Deep Learning", "author": "Ian Goodfellow", "price": 1200, "in_stock": True},
    {"id": 2, "title": "Python Tricks", "author": "Dan Bader", "price": 600, "in_stock": True},
    {"id": 3, "title": "Clean Code", "author": "Robert C. Martin", "price": 800, "in_stock": False},
    {"id": 4, "title": "Fluent Python", "author": "Luciano Ramalho", "price": 900, "in_stock": True}
]


# Get all books
@app.get("/books")
def get_all_books():
    return {"books": books}


# Get book by ID
@app.get("/books/{book_id}")
def get_book(book_id: int):
    for book in books:
        if book["id"] == book_id:
            return book
    raise HTTPException(status_code=404, detail="Book not found")


# Add a new book
@app.post("/books", status_code=201)
def add_book(book: Book):
    ids = [b["id"] for b in books]
    if book.id in ids:
        raise HTTPException(status_code=400, detail="Duplicate ID not allowed")
    books.append(book.dict())
    return {"message": "Book added successfully", "book": book}


# Update a book
@app.put("/books/{book_id}")
def update_book(book_id: int, updated_book: Book):
    for i, b in enumerate(books):
        if b["id"] == book_id:
            books[i] = updated_book.dict()
            return {"message": "Book updated successfully", "book": updated_book}
    raise HTTPException(status_code=404, detail="Book not found")


# Delete a book
@app.delete("/books/{book_id}")
def delete_book(book_id: int):
    for i, b in enumerate(books):
        if b["id"] == book_id:
            books.pop(i)
            return {"message": "Book deleted successfully"}
    raise HTTPException(status_code=404, detail="Book not found")


# Search books (author / max_price)
@app.get("/books/search")
def search_books(author: Optional[str] = None, max_price: Optional[float] = None):
    results = books
    if author:
        results = [b for b in results if b["author"].lower() == author.lower()]
    if max_price is not None:
        results = [b for b in results if b["price"] <= max_price]
    return {"results": results}


# Get only available books
@app.get("/books/available")
def get_available_books():
    return {"available_books": [b for b in books if b["in_stock"]]}


# Count total books
@app.get("/books/count")
def get_book_count():
    return {"count": len(books)}


# Run: uvicorn bookstore_api:app --reload
